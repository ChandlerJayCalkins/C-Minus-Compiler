// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN
// PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN PAIN

#include <string.h>
#include <cstdlib>
#include "codeGen.h"

int goffset; // current global offset in data memory
int foffset; // current frame offset in data memory
int iaddr; // current instruction address location
bool inFunc; // whether or not a function is currently being traversed
FILE* codeFile; // file to output code to
std::string divider; // string of stars to visually separate functions in the code
extern TreeNode* ast; // abstract syntax tree

// evaluates expressions and then stores the result in ac1
void evaluateExp(TreeNode* node);
// generates code to compare 2 arrays
void compareArrays(TreeNode* lhs, TreeNode* rhs, TreeNode* op);
// puts the address of an array into register r
void loadArrayAddr(TreeNode* array, int r);
// puts the address of an element in an array into ac1 (uses ac1 and ac2 in the process)
void loadIndexAddr(TreeNode* array, TreeNode* index, bool printEnd);

void outputComment(std::string comment);
void outputCommentWithLine(TreeNode* node, std::string comment);
void outputOpStartComment(TreeNode* node);
void outputOpEndComment(TreeNode* node);
int outputRTMInstruction(std::string instr, int r, int d, int s, std::string comment);
int outputRTMInstruction(int addr, std::string instr, int r, int d, int s, std::string comment);
int outputRTMInstruction(std::string instr, int r, char d, int s, std::string comment);
int outputInstruction(std::string instr, int r, int s, int t, std::string comment);
void outputLitInstruction(int addr, char* str, int size);

// list of function names and their start addresses in instruction memory
class FuncList
{
	private:
		std::string name;
		int addr;
		FuncList* next;
	public:
		FuncList(char* name, int addr, FuncList* next)
		{
			this->name = name;
			this->addr = addr;
			this->next = next;
		}

		int findFuncAddr(std::string name)
		{
			if (this->name == name)
			{
				return this->addr;
			}
			else if (this->next == NULL)
			{
				return -1;
			}
			else
			{
				return next->findFuncAddr(name);
			}
		}
};

// list of global and static variables to be initialized at the start of a program
class GlobalList
{
	private:
		TreeNode* node;
		GlobalList* next;
	public:
		GlobalList(TreeNode* node, GlobalList* next)
		{
			this->node = node;
			this->next = next;
		}

		void genInitStaticCode()
		{
			std::string name = node->value.str;
			char temp[21];
			sprintf(temp, "%d", node->foffset);
			std::string loc = temp;
			outputCommentWithLine(node, "START declaration of variable " + name + " at loc " + loc);

			// if the variable has an initialization value
			if (node->children[0] != NULL)
			{
				// if rhs is not an array
				if (!node->children[0]->isArray)
				{
					// load the initialization value into ac1
					evaluateExp(node->children[0]);

					// if the variable is stored in local space
					if (node->memSpace == Local)
					{
						outputRTMInstruction("ST", 3, node->foffset, 1, "Store expression result into variable");
					}
					// if the variable is stored in global space or static space
					else
					{
						outputRTMInstruction("ST", 3, node->foffset, 0, "Store expression result into variable");
					}
				}
				// if rhs is an array
				else
				{
					// load the lhs address into ac1
					loadArrayAddr(node, 3);
					// load lhs array size into ac2 and store it in array[-1]
					outputRTMInstruction("LDC", 4, node->size - 1, 0, "Load size of lhs array into ac2");
					outputRTMInstruction("ST", 4, 1, 3, "Store size of lhs array into array[-1]");

					// if the rhs is a parameter
					if (node->children[0]->memSpace == Parameter)
					{
						outputRTMInstruction("LD", 4, node->children[0]->foffset, 1, "Load rhs address into ac2");
					}
					// if the rhs is stored in global space
					else if (node->children[0]->memSpace == Global || node->children[0]->memSpace == Static)
					{
						// if the rhs is a const string, load it into memory
						if (node->children[0]->nodeType == Const)
						{
							outputLitInstruction(node->children[0]->foffset, node->children[0]->value.str, node->children[0]->size);
						}
						outputRTMInstruction("LDA", 4, node->children[0]->foffset, 0, "Load rhs address into ac2");
					}
					// if the rhs is just in local memory
					else
					{
						outputRTMInstruction("LDA", 4, node->children[0]->foffset, 1, "Load rhs address into ac2");
					}

					// determine which array is smaller and use that array's size for the move instruction
					outputRTMInstruction("LD", 5, 1, 3, "Load lhs array size into ac3");
					outputRTMInstruction("LD", 6, 1, 4, "Load rhs array size into ac4");
					outputInstruction("SWP", 5, 6, 6, "Put smaller array size in ac3");
					
					// move values of rhs array to lhs array
					outputInstruction("MOV", 3, 4, 5, "Move values of rhs array to lhs array");
				}
			}
			
			// decrement the offsets

			// if the node is not an array
			if (!node->isArray)
			{
				// if the node is in local space, decrement the foffset
				if (node->memSpace == Local)
				{
					foffset--;
				}
				// if the node is in static or global space, decrement the goffset
				else
				{
					goffset--;
					// if the node is in global space, decrement the foffset too
					if (node->memSpace == Global)
					{
						foffset--;
					}
				}
			}
			// if the node is an array
			else
			{
				// if the array's address hasn't been loaded yet, load it
				if (node->children[0] == NULL)
				{
					loadArrayAddr(node, 3);
					outputRTMInstruction("LDC", 4, node->size - 1, 4, "Load size of array into ac2");
					outputRTMInstruction("ST", 4, 1, 3, "Store size of lhs array into array[-1]");
				}

				// if the array is stored in local space, decrease the frame offset
				if (node->memSpace == Local)
				{
					foffset -= node->size + 1;
				}
				// if the array is stored in global / static space, decrease the global offset
				else
				{
					goffset -= node->size + 1;
					// decrease the foffset too if the program is currently in global space
					if (node->memSpace == Global)
					{
						foffset -= node->size + 1;
					}
				}
			}

			outputCommentWithLine(node, "END declaration of variable " + name);
			if (next != NULL)
			{
				next->genInitStaticCode();
			}
		}
};

class BreakNode
{
	private:
		int addr;
		BreakNode* next;
	public:
		BreakNode(int addr, BreakNode* next)
		{
			this->addr = addr;
			this->next = next;
			iaddr++;
		}

		void outputBreaks()
		{
			outputRTMInstruction(addr, "JMP", 7, iaddr - addr - 1, 7, "Break");
			if (next != NULL)
			{
				next->outputBreaks();
			}
		}
};

class BreakList
{
	private:
		BreakNode* start;
		BreakList* next;

	public:
		BreakList(BreakList* next)
		{
			start = NULL;
			this->next = next;
		}

		void addBreak(int addr)
		{
			start = new BreakNode(addr, start);
		}

		void outputBreaks()
		{
			if (start != NULL)
			{
				start->outputBreaks();
			}
		}

		BreakList* getNext()
		{
			return next;
		}
};

FuncList* funcList;
GlobalList* globalList;
BreakList* breakList;

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Kick-off and traversing functions
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////

// main function for generating code for the tiny machine vm
void generateCode(char* fileName)
{
	strncat(fileName, ".tm", 3);
	divider = "* ** ** ** ** ** ** ** ** ** ** ** **";

	goffset = 0;
	foffset = 0;
	iaddr = 39;
	inFunc = false;
	globalList = NULL;
	breakList = NULL;

	genHeader(fileName);

	codeFile = fopen(fileName, "a");


	traverseAST(ast);

	genInitCode();

	fclose(codeFile);
}

// generates code and comments that go at the top of the output code file
void genHeader(char* fileName)
{
	std::ofstream file;
	// clear previous contents of file
	file.open(fileName, std::ios_base::trunc);
	file.close();
	// reopen file in append mode
	file.open(fileName, std::ios_base::app);

	// output all of the built in functions to the file
	file << divider << '\n';
	file << "* FUNCTION input\n";
	file << "  1:     ST  3,-1(1)	Store return address \n";
	file << "  2:     IN  2,2,2	Grab int input \n";
	file << "  3:     LD  3,-1(1)	Load return address \n";
	file << "  4:     LD  1,0(1)	Adjust fp \n";
	file << "  5:    JMP  7,0(3)	Return \n";
	file << "* END FUNCTION input\n";
	file << "* \n";
	file << divider << '\n';
	file << "* FUNCTION inputb\n";
	file << "  6:     ST  3,-1(1)	Store return address \n";
	file << "  7:    INB  2,2,2	Grab bool input \n";
	file << "  8:     LD  3,-1(1)	Load return address \n";
	file << "  9:     LD  1,0(1)	Adjust fp \n";
	file << " 10:    JMP  7,0(3)	Return \n";
	file << "* END FUNCTION inputb\n";
	file << "* \n";
	file << divider << '\n';
	file << "* FUNCTION inputc\n";
	file << " 11:     ST  3,-1(1)	Store return address \n";
	file << " 12:    INC  2,2,2	Grab char input \n";
	file << " 13:     LD  3,-1(1)	Load return address \n";
	file << " 14:     LD  1,0(1)	Adjust fp \n";
	file << " 15:    JMP  7,0(3)	Return \n";
	file << "* END FUNCTION inputc\n";
	file << "* \n";
	file << divider << '\n';
	file << "* FUNCTION output\n";
	file << " 16:     ST  3,-1(1)	Store return address \n";
	file << " 17:     LD  3,-2(1)	Load parameter \n";
	file << " 18:    OUT  3,3,3	Output integer \n";
	file << " 19:     LD  3,-1(1)	Load return address \n";
	file << " 20:     LD  1,0(1)	Adjust fp \n";
	file << " 21:    JMP  7,0(3)	Return \n";
	file << "* END FUNCTION output\n";
	file << "* \n";
	file << divider << '\n';
	file << "* FUNCTION outputb\n";
	file << " 22:     ST  3,-1(1)	Store return address \n";
	file << " 23:     LD  3,-2(1)	Load parameter \n";
	file << " 24:   OUTB  3,3,3	Output bool \n";
	file << " 25:     LD  3,-1(1)	Load return address \n";
	file << " 26:     LD  1,0(1)	Adjust fp \n";
	file << " 27:    JMP  7,0(3)	Return \n";
	file << "* END FUNCTION outputb\n";
	file << "* \n";
	file << divider << '\n';
	file << "* FUNCTION outputc\n";
	file << " 28:     ST  3,-1(1)	Store return address \n";
	file << " 29:     LD  3,-2(1)	Load parameter \n";
	file << " 30:   OUTC  3,3,3	Output char \n";
	file << " 31:     LD  3,-1(1)	Load return address \n";
	file << " 32:     LD  1,0(1)	Adjust fp \n";
	file << " 33:    JMP  7,0(3)	Return \n";
	file << "* END FUNCTION outputc\n";
	file << "* \n";
	file << divider << '\n';
	file << "* FUNCTION outnl\n";
	file << " 34:     ST  3,-1(1)	Store return address \n";
	file << " 35:  OUTNL  3,3,3	Output a newline \n";
	file << " 36:     LD  3,-1(1)	Load return address \n";
	file << " 37:     LD  1,0(1)	Adjust fp \n";
	file << " 38:    JMP  7,0(3)	Return \n";
	file << "* END FUNCTION outnl\n";
	file << "* \n";
	file << divider << '\n';

	file.close();

	std::string funcName = "input";
	funcList = new FuncList(&funcName[0], 1, NULL);
	funcName = "inputb";
	funcList = new FuncList(&funcName[0], 6, funcList);
	funcName = "inputc";
	funcList = new FuncList(&funcName[0], 11, funcList);
	funcName = "output";
	funcList = new FuncList(&funcName[0], 16, funcList);
	funcName = "outputb";
	funcList = new FuncList(&funcName[0], 22, funcList);
	funcName = "outputc";
	funcList = new FuncList(&funcName[0], 28, funcList);
	funcName = "outnl";
	funcList = new FuncList(&funcName[0], 34, funcList);
}

// generates inititalization code
void genInitCode()
{
	outputRTMInstruction(0, "JMP", 7, iaddr - 1, 7, "Jump to INIT [backpactch]");

	outputComment("INIT");

	outputComment("STATIC INIT");
	if (globalList != NULL)
	{
		globalList->genInitStaticCode();
	}
	outputComment("END STATIC INIT");

	outputRTMInstruction("LDA", 1, goffset, 0, "Set first frame pointer at end of globals");
	outputRTMInstruction("ST", 1, 0, 1, "Store first frame pointer");
	outputRTMInstruction("LDA", 3, 1, 7, "Store return address in ac1 that goes to halt instruction at the end");
	int mainAddr = funcList->findFuncAddr("main");
	mainAddr -= iaddr + 1;
	outputRTMInstruction("JMP", 7, mainAddr, 7, "Jump to main");
	outputInstruction("HALT", 0, 0, 0, "End of program");
}

// traverses the ast to generate code
void traverseAST(TreeNode* node)
{
	switch (node->nodeType)
	{
		case Var:
			genVarCode(node);
			break;
		case Func:
			genFuncCode(node);
			break;
		case Compound:
			genCompoundCode(node);
			break;
		case If:
			genIfCode(node);
			break;
		case While:
			genWhileCode(node);
			break;
		case For:
			genForCode(node);
			break;
		case Break:
			genBreakCode(node);
			break;
		case Call:
			genCallCode(node);
			break;
		case Return:
			genReturnCode(node);
			break;
		case Assign:
			switch (node->opKind)
			{
				case Inc:
					genIncCode(node);
					break;
				case Dec:
					genIncCode(node);
					break;
				case Assi:
					genAssiCode(node);
					break;
				case Addas:
					genAssiCode(node);
					break;
				case Subas:
					genAssiCode(node);
					break;
				case Mulas:
					genAssiCode(node);
					break;
				case Divas:
					genAssiCode(node);
					break;
				default:
					traverseChildren(node);
					traverseSib(node);
			}
			break;
		case Op:
			switch (node->opKind)
			{
				case Or:
					genBinOpCode(node);
					break;
				case And:
					genBinOpCode(node);
					break;
				case Not:
					genUnaryOpCode(node);
					break;
				case Less:
					genBinOpCode(node);
					break;
				case Leq:
					genBinOpCode(node);
					break;
				case Gtr:
					genBinOpCode(node);
					break;
				case Geq:
					genBinOpCode(node);
					break;
				case Eq:
					genBinOpCode(node);
					break;
				case Neq:
					genBinOpCode(node);
					break;
				case Add:
					genBinOpCode(node);
					break;
				case Sub:
					genBinOpCode(node);
					break;
				case Mul:
					genBinOpCode(node);
					break;
				case Div:
					genBinOpCode(node);
					break;
				case Mod:
					genBinOpCode(node);
					break;
				case Neg:
					genUnaryOpCode(node);
					break;
				case Size:
					genSizeCode(node);
					break;
				case Rand:
					genUnaryOpCode(node);
					break;
				case Brak:
					genBrakCode(node);
					break;
				default:
					traverseChildren(node);
					traverseSib(node);
			}
			break;
		default:
			traverseChildren(node);
			traverseSib(node);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Traversing children and sibling nodes
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////

// calls traverseAST on all of a node's children
void traverseChildren(TreeNode* node)
{
	for (int i = 0; i < maxChildren; i++)
	{
		if (node->children[i] != NULL)
		{
			traverseAST(node->children[i]);
		}
	}
}

// calls traverseAST on a node's sibling if it has one
void traverseSib(TreeNode* node)
{
	// if the node has a sibling
	if (node->sibling != NULL)
	{
		traverseAST(node->sibling);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Generating code for each node type
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////

// generates code for a variable declaration
void genVarCode(TreeNode* node)
{
	// if this variable is static
	if (node->isStatic || node->memSpace == Global)
	{
		globalList = new GlobalList(node, globalList);
		traverseSib(node);
		return;
	}

	std::string name = node->value.str;
	char temp[21];
	sprintf(temp, "%d", node->foffset);
	std::string loc = temp;
	outputCommentWithLine(node, "START declaration of variable " + name + " at loc " + loc);

	// if the variable has an initialization value
	if (node->children[0] != NULL)
	{
		// if rhs is not an array
		if (!node->children[0]->isArray)
		{
			// load the initialization value into ac1
			evaluateExp(node->children[0]);

			// if the variable is stored in local space
			if (node->memSpace == Local)
			{
				outputRTMInstruction("ST", 3, node->foffset, 1, "Store expression result into variable");
			}
			// if the variable is stored in global space or static space
			else
			{
				outputRTMInstruction("ST", 3, node->foffset, 0, "Store expression result into variable");
			}
		}
		// if rhs is an array
		else
		{
			// load the lhs address into ac1
			loadArrayAddr(node, 3);
			// load lhs array size into ac2 and store it in array[-1]
			outputRTMInstruction("LDC", 4, node->size - 1, 0, "Load size of lhs array into ac2");
			outputRTMInstruction("ST", 4, 1, 3, "Store size of lhs array into array[-1]");

			// if the rhs is a parameter
			if (node->children[0]->memSpace == Parameter)
			{
				outputRTMInstruction("LD", 4, node->children[0]->foffset, 1, "Load rhs address into ac2");
			}
			// if the rhs is stored in global space
			else if (node->children[0]->memSpace == Global || node->children[0]->memSpace == Static)
			{
				// if the rhs is a const string, load it into memory
				if (node->children[0]->nodeType == Const)
				{
					outputLitInstruction(node->children[0]->foffset, node->children[0]->value.str, node->children[0]->size);
				}
				outputRTMInstruction("LDA", 4, node->children[0]->foffset, 0, "Load rhs address into ac2");
			}
			// if the rhs is just in local memory
			else
			{
				outputRTMInstruction("LDA", 4, node->children[0]->foffset, 1, "Load rhs address into ac2");
			}

			// determine which array is smaller and use that array's size for the move instruction
			outputRTMInstruction("LD", 5, 1, 3, "Load lhs array size into ac3");
			outputRTMInstruction("LD", 6, 1, 4, "Load rhs array size into ac4");
			outputInstruction("SWP", 5, 6, 6, "Put smaller array size in ac3");
			
			// move values of rhs array to lhs array
			outputInstruction("MOV", 3, 4, 5, "Move values of rhs array to lhs array");
		}
	}
	
	// decrement the offsets

	// if the node is not an array
	if (!node->isArray)
	{
		// if the node is in local space, decrement the foffset
		if (node->memSpace == Local)
		{
			foffset--;
		}
		// if the node is in static or global space, decrement the goffset
		else
		{
			goffset--;
			// if the node is in global space, decrement the foffset too
			if (node->memSpace == Global)
			{
				foffset--;
			}
		}
	}
	// if the node is an array
	else
	{
		// if the array's address hasn't been loaded yet, load it
		if (node->children[0] == NULL)
		{
			loadArrayAddr(node, 3);
			outputRTMInstruction("LDC", 4, node->size - 1, 4, "Load size of array into ac2");
			outputRTMInstruction("ST", 4, 1, 3, "Store size of lhs array into array[-1]");
		}

		// if the array is stored in local space, decrease the frame offset
		if (node->memSpace == Local)
		{
			foffset -= node->size + 1;
		}
		// if the array is stored in global / static space, decrease the global offset
		else
		{
			goffset -= node->size + 1;
			// decrease the foffset too if the program is currently in global space
			if (node->memSpace == Global)
			{
				foffset -= node->size + 1;
			}
		}
	}

	outputCommentWithLine(node, "END declaration of variable " + name);
	traverseSib(node);
}

// generates code for a function declaration
void genFuncCode(TreeNode* node)
{
	inFunc = true;
	funcList = new FuncList(node->value.str, iaddr, funcList);
	std::string funcName = node->value.str;
	outputComment("");
	outputComment(divider);
	outputCommentWithLine(node, "FUNCTION " + funcName);

	outputRTMInstruction("ST", 3, -1, 1, "Store Return address");
	// count how many parameters this functions has, and then set the new foffset to -2 minus the number of parameters since each parameter only takes up 1 unit of space
	int parms = 0;
	for (TreeNode* parm = node->children[0]; parm != NULL; parm = parm->sibling)
	{
		parms++;
	}
	foffset = -2 - parms;
	traverseChildren(node);
	foffset = goffset;

	outputComment("Add default return statement in case there isn't already one");
	// if the function returns an int or a bool
	if (node->expType != Char)
	{
		outputRTMInstruction("LDC", 2, 0, 6, "Store return value");
	}
	// if the function returns a char
	else
	{
		outputRTMInstruction("LDC", 2, ' ', 6, "Store return value");
	}
	outputRTMInstruction("LD", 3, -1, 1, "Load return address");
	outputRTMInstruction("LD", 1, 0, 1, "Adjust frame pointer to what it was before");
	outputRTMInstruction("JMP", 7, 0, 3, "Return");

	outputComment("END FUNCTION " + funcName);
	inFunc = false;
	traverseSib(node);
}

// generates code for a compound statement
void genCompoundCode(TreeNode* node)
{
	outputCommentWithLine(node, "Compound Statement START");
	int oldOffset = foffset;
	traverseChildren(node);
	foffset = oldOffset;
	outputComment("Compound Statement END");
	traverseSib(node);
}

// generates code for an if statement
void genIfCode(TreeNode* node)
{
	outputCommentWithLine(node, "IF");

	outputComment("Test condition:");
	// evaluate the test condition and store result in ac1
	evaluateExp(node->children[0]);
	// store address of jump statement that will skip over then part if test condition is false
	int jumpAddr = iaddr;
	// set iaddr to address of then part instructions
	iaddr++;

	outputComment("THEN");
	// if there is a then part, generate instructions inside then part
	if (node->children[1] != NULL)
	{
		traverseAST(node->children[1]);
	}
	// if there is no else part, set jump to right after then part
	// if there is an else part, jump 1 farther to account for instruction inside then part that skips over else part that will be generated after else part is traversed
	int skipAddr = node->children[2] == NULL ? iaddr - jumpAddr - 1 : iaddr - jumpAddr;
	outputRTMInstruction(jumpAddr, "JZR", 3, skipAddr, 7, "Jump around THEN if false [backpatch]");

	// if there is an else part
	if (node->children[2] != NULL)
	{
		// store address of jump statement that will skip over else part
		jumpAddr = iaddr;
		// set iaddr to address of else part instructions
		iaddr++;
		outputComment("ELSE");
		traverseAST(node->children[2]);
		skipAddr = iaddr - jumpAddr - 1;
		outputRTMInstruction(jumpAddr, "JMP", 7, skipAddr, 7, "Jump around ELSE [backpatch]");
	}

	outputCommentWithLine(node, "END IF");
	traverseSib(node);
}

// generates code for a while loop
void genWhileCode(TreeNode* node)
{
	outputCommentWithLine(node, "WHILE");
	breakList = new BreakList(breakList);
	
	// store exact location of start of test condition to go back to after each loop cycle
	int testAddr = iaddr;
	outputComment("Test condition:");
	// evaluate the test condition and store result in ac1
	evaluateExp(node->children[0]);
	// store address of jump statement that will skip over do part if test condition is false
	int jumpAddr = iaddr;
	// set iaddr to address of do part instructions
	iaddr++;

	outputComment("DO");
	// if there is a do part, generate instructions inside do part
	if (node->children[1] != NULL)
	{
		traverseAST(node->children[1]);
	}
	// turn test address into location relative to pc
	testAddr -= iaddr + 1;
	outputRTMInstruction("JMP", 7, testAddr, 7, "Jump back to test condition");
	outputRTMInstruction(jumpAddr, "JZR", 3, iaddr - jumpAddr - 1, 7, "Jump around DO if false [backpatch]");

	breakList->outputBreaks();
	breakList = breakList->getNext();
	outputCommentWithLine(node, "END WHILE");
	traverseSib(node);
}

// generates code for a for loop
void genForCode(TreeNode* node)
{
	outputCommentWithLine(node, "FOR");
	breakList = new BreakList(breakList);
	TreeNode* stepNode = node->children[1]->children[2];
	TreeNode* stopNode = node->children[1]->children[1];
	TreeNode* indexNode = node->children[1]->children[0];
	// if there is a step value in the range statement
	if (stepNode != NULL)
	{
		// evaluate the step value and store it in the stack
		evaluateExp(stepNode);
		outputRTMInstruction("ST", 3, foffset, 1, "Store step value");
	}
	// if there is not step value in the range statement
	else
	{
		// store 1 as the default step value in the stack
		outputRTMInstruction("LDC", 3, 1, 6, "Load step value into ac1");
		outputRTMInstruction("ST", 3, foffset, 1, "Store step value");
	}
	// store location of step value and decement frame offset
	int stepAddr = foffset;
	foffset--;
	// evaluate the stop value, store it in the stack, store location of stop value, and decrement the foffset
	evaluateExp(stopNode);
	outputRTMInstruction("ST", 3, foffset, 1, "Store stop value");
	int stopAddr = foffset;
	foffset--;
	// evaluate the first index value, store it in the stack, store location of index, and decrement the foffset
	evaluateExp(indexNode);
	outputRTMInstruction("ST", 3, foffset, 1, "Store starting index value");
	int indexAddr = foffset;
	foffset--;

	// store exact location of start of test condition to go back to after each loop cycle
	int testAddr = iaddr;
	outputComment("Test condition:");
	// test if index is less than stop value
	outputRTMInstruction("LD", 4, indexAddr, 1, "Load index value");
	outputRTMInstruction("LD", 5, stopAddr, 1, "Load stop value");
	outputRTMInstruction("LD", 3, stepAddr, 1, "Load step value");
	outputInstruction("SLT", 3, 4, 5, "See if index < stop value, store result in ac1");
	// store address of jump statement that will skip over do part if test condition is false
	int jumpAddr = iaddr;
	// set iaddr to address of do part instructions
	iaddr++;

	outputComment("DO");
	// if there is a do part, generate instructions inside do part
	if (node->children[2] != NULL)
	{
		traverseAST(node->children[2]);
	}
	// increase index value by step value
	outputRTMInstruction("LD", 3, indexAddr, 1, "Load index value");
	outputRTMInstruction("LD", 4, stepAddr, 1, "Load step value");
	outputInstruction("ADD", 3, 3, 4, "Add step value to index value");
	outputRTMInstruction("ST", 3, indexAddr, 1, "Store new index value");
	// turn test address into location relative to pc
	testAddr -= iaddr + 1;
	outputRTMInstruction("JMP", 7, testAddr, 7, "Jump back to test condition");
	if (breakList != NULL)
	{
		breakList->outputBreaks();
	}
	outputRTMInstruction(jumpAddr, "JZR", 3, iaddr - jumpAddr - 1, 7, "Jump around DO if false [backpatch]");

	breakList->outputBreaks();
	breakList = breakList->getNext();
	foffset += 3;
	outputCommentWithLine(node, "END FOR");
	traverseSib(node);
}

// generates code for a break statement
void genBreakCode(TreeNode* node)
{
	breakList->addBreak(iaddr);
	traverseSib(node);
}

// generates code for a call statement
void genCallCode(TreeNode* node)
{
	std::string funcName = node->value.str;
	outputCommentWithLine(node, "CALL " + funcName);

	int oldOffset = foffset;
	outputRTMInstruction("ST", 1, foffset, 1, "Store new frame pointer at top of new frame stack");
	foffset -= 2;
	int parmCount = 1;
	// load each parameter into the next frame
	for (TreeNode* parm = node->children[0]; parm != NULL; parm = parm->sibling)
	{
		char temp[21];
		sprintf(temp, "%d", parmCount);
		std::string parmCountStr = temp;
		outputComment("START Parameter " + parmCountStr);
		// load parameter value into ac1
		evaluateExp(parm);
		outputRTMInstruction("ST", 3, foffset, 1, "Store parameter in next frame");
		outputComment("END Parameter " + parmCountStr);
		parmCount++;
		foffset--;
	}

	foffset = oldOffset;
	outputRTMInstruction("LDA", 1, foffset, 1, "Set new frame pointer");
	outputRTMInstruction("LDA", 3, 1, 7, "Put return address in ac1");
	int funcAddr = funcList->findFuncAddr(funcName);
	outputRTMInstruction("JMP", 7, funcAddr - (iaddr + 1), 7, "GOTO " + funcName);

	outputCommentWithLine(node, "END CALL " + funcName);
	traverseSib(node);
}

// generates code for a return statement
void genReturnCode(TreeNode* node)
{
	outputCommentWithLine(node, "RETURN START");

	// if the return statement has a return value, load the return value
	if (node->children[0] != NULL)
	{
		evaluateExp(node->children[0]);
		outputRTMInstruction("LDA", 2, 0, 3, "Store return value");
	}

	outputRTMInstruction("LD", 3, -1, 1, "Load return address");
	outputRTMInstruction("LD", 1, 0, 1, "Adjust frame pointer to what it was before");
	outputRTMInstruction("JMP", 7, 0, 3, "Return");

	outputCommentWithLine(node, "RETURN END");
	traverseSib(node);
}

// generates code for increment operators
void genIncCode(TreeNode* node)
{
	outputOpStartComment(node);

	// if operand is not an array element
	if (node->children[0]->opKind != Brak)
	{
		if (node->children[0]->memSpace == Local || node->children[0]->memSpace == Parameter)
		{
			outputRTMInstruction("LD", 3, node->children[0]->foffset, 1, "Load variable into ac1");
		}
		else
		{
			outputRTMInstruction("LD", 3, node->children[0]->foffset, 0, "Load variable into ac1");
		}
	}
	// if operand is an array element
	else
	{
		// calculate address of element and store it in stack temporarily
		loadIndexAddr(node->children[0]->children[0], node->children[0]->children[1], true);
		outputRTMInstruction("LDA", 4, 0, 3, "Move element address to ac2");
		outputRTMInstruction("LD", 3, 0, 4, "Load element value into ac1");
	}

	// if the operator is an increment assignment
	if (node->opKind == Inc)
	{
		outputInstruction("LDA", 3, 1, 3, "Increment variable");
	}
	// if the operator is a decrement assignment
	else
	{
		outputInstruction("LDA", 3, -1, 3, "Decrement variable");
	}

	// if operand is not an array element
	if (node->children[0]->opKind != Brak)
	{
		if (node->children[0]->memSpace == Local || node->children[0]->memSpace == Parameter)
		{
			outputRTMInstruction("ST", 3, node->children[0]->foffset, 1, "Store value into dmem");
		}
		else
		{
			outputRTMInstruction("ST", 3, node->children[0]->foffset, 0, "Store value into dmem");
		}
	}
	// if operand is an array element
	else
	{
		// calculate address of element and store it in stack temporarily
		outputRTMInstruction("ST", 3, 0, 4, "Store value into dmem");
	}

	outputOpEndComment(node);
	traverseSib(node);
}

// generates code for an assign operator
void genAssiCode(TreeNode* node)
{
	outputOpStartComment(node);

	// if this is not an array assignment
	if (!node->children[0]->isArray)
	{
		// if lhs is an array element
		if (node->children[0]->opKind == Brak)
		{
			// calculate address of element and store it in stack temporarily
			loadIndexAddr(node->children[0]->children[0], node->children[0]->children[1], true);
			outputRTMInstruction("ST", 3, foffset, 1, "Store lhs element address in dmem");
			foffset--;
		}

		// load rhs into ac1
		evaluateExp(node->children[1]);

		// if this is an operate by and then assign operator
		if (node->opKind != Assi)
		{
			// if the lhs is not an array element
			if (node->children[0]->opKind != Brak)
			{
				// if the variable is stored in local or parameter space
				if (node->children[0]->memSpace == Local || node->children[0]->memSpace == Parameter)
				{
					outputRTMInstruction("LD", 4, node->children[0]->foffset, 1, "Load lhs variable value into ac2");
				}
				// if the variable is stored in static or global space
				else
				{
					outputRTMInstruction("LD", 4, node->children[0]->foffset, 0, "Load lhs variable value into ac2");
				}
			}
			// if the lhs is an array element
			else
			{
				// pop element address off of stack and load its value into ac2
				foffset++;
				outputRTMInstruction("LD", 5, foffset, 1, "Load lhs element address into ac3");
				outputRTMInstruction("LD", 4, 0, 5, "Load lhs element value into ac2");
			}

			// do the operation
			switch (node->opKind)
			{
				case Addas:
					outputInstruction("ADD", 3, 4, 3, "Add rhs to variable value into ac1");
					break;
				case Subas:
					outputInstruction("SUB", 3, 4, 3, "Subtract rhs from variable value into ac1");
					break;
				case Mulas:
					outputInstruction("MUL", 3, 4, 3, "Multiply variable value by rhs into ac1");
					break;
				case Divas:
					outputInstruction("DIV", 3, 4, 3, "Divide variable value by rhs into ac1");
					break;
				default:
					printf("ERROR(CodeGen): Unrecognized Operator\n");
			}
		}

		// if the lhs is not an array element
		if (node->children[0]->opKind != Brak)
		{
			// store the value in the memory location of the variable
			if (node->children[0]->memSpace == Local || node->children[0]->memSpace == Parameter)
			{
				outputRTMInstruction("ST", 3, node->children[0]->foffset, 1, "Store value into variable location");
			}
			else
			{
				outputRTMInstruction("ST", 3, node->children[0]->foffset, 0, "Store value into variable location");
			}
		}
		// is the lhs is an array element
		else
		{
			// if the address of the element wasn't already loaded
			if (node->opKind == Assi)
			{
				// pop address of element off of stack
				foffset++;
				outputRTMInstruction("LD", 5, foffset, 1, "Load lhs element address into ac3");
			}
			outputRTMInstruction("ST", 3, 0, 5, "Store value into indexed location");
		}
	}
	// if this an array assignment
	else
	{
		loadArrayAddr(node->children[0], 3);
		loadArrayAddr(node->children[1], 4);
		outputRTMInstruction("LD", 5, 1, 3, "Store size of lhs array in ac3");
		outputRTMInstruction("LD", 6, 1, 4, "Store size of rhs array in ac4");
		outputInstruction("SWP", 5, 6, 6, "Get smaller array size in ac3");
		outputInstruction("MOV", 3, 4, 5, "Copy over elements of rhs array into lhs array");
	}

	outputOpEndComment(node);
	traverseSib(node);
}

// generates code for binary operators
void genBinOpCode(TreeNode* node)
{
	outputOpStartComment(node);

	// if left hand side is either an expression or an assignment, evaluate that first and store value in dmem
	if (node->children[0]->nodeType == Assign || node->children[0]->nodeType == Op)
	{
		traverseAST(node->children[0]);
		outputRTMInstruction("ST", 3, foffset, 1, "Store lhs exp result in dmem");
		foffset--;
	}
	// if the left hand side is a function call, evaluate that first and then store the value in dmem
	else if (node->children[0]->nodeType == Call)
	{
		traverseAST(node->children[0]);
		outputRTMInstruction("ST", 2, foffset, 1, "Store lhs call result in dmem");
		foffset--;
	}

	// if right hand side is either an expression or an assignment, evaluate that first and store value in dmem
	if (node->children[1]->nodeType == Assign || node->children[1]->nodeType == Op)
	{
		traverseAST(node->children[1]);
		outputRTMInstruction("ST", 3, foffset, 1, "Store rhs exp result in dmem");
		foffset--;
	}
	// if the right hand side is a function call, evaluate that first and then store the value in dmem
	else if (node->children[1]->nodeType == Call)
	{
		traverseAST(node->children[1]);
		outputRTMInstruction("ST", 2, foffset, 1, "Store rhs call result in dmem");
		foffset--;
	}

	// if right hand side was an expression, assignment, or function call, pop the result off of the stack into ac2
	if (node->children[1]->nodeType == Assign || node->children[1]->nodeType == Op || node->children[1]->nodeType == Call)
	{
		foffset++;
		outputRTMInstruction("LD", 4, foffset, 1, "Load rhs exp result back into ac2");
	}
	// if right hand side was an id and not an array, load that id's value from the stack into ac2
	else if (node->children[1]->nodeType == Id && !node->children[1]->isArray)
	{
		if (node->children[1]->memSpace == Local || node->children[1]->memSpace == Parameter)
		{
			outputRTMInstruction("LD", 4, node->children[1]->foffset, 1, "Load variable into ac2");
		}
		else
		{
			outputRTMInstruction("LD", 4, node->children[1]->foffset, 0, "Load variable into ac2");
		}
	}
	// if right hand side was a constant and not an array (string), load that value into ac2
	else if (node->children[1]->nodeType == Const && !node->children[1]->isArray)
	{
		// if the constant is an int or a bool
		if (node->children[1]->expType != Char)
		{
			outputRTMInstruction("LDC", 4, node->children[1]->value.num, 4, "Load Constant into ac2");
		}
		// if the constant is a char
		else
		{
			outputRTMInstruction("LDC", 4, node->children[1]->value.ch, 4, "Load Constant into ac2");
		}
	}

	// if left hand side was an expression, assignment, or function call, pop the result off of the stack into ac1
	if (node->children[0]->nodeType == Assign || node->children[0]->nodeType == Op || node->children[0]->nodeType == Call)
	{
		foffset++;
		outputRTMInstruction("LD", 3, foffset, 1, "Load lhs exp result back into ac1");
	}
	// if left hand side was an id and not an array, load that id's value from the stack into ac1
	else if (node->children[0]->nodeType == Id && !node->children[0]->isArray)
	{
		if (node->children[0]->memSpace == Local || node->children[0]->memSpace == Parameter)
		{
			outputRTMInstruction("LD", 3, node->children[0]->foffset, 1, "Load variable into ac1");
		}
		else
		{
			outputRTMInstruction("LD", 3, node->children[0]->foffset, 0, "Load variable into ac1");
		}
	}
	// if left hand side was a constant and not an array (string), load that value into ac1
	else if (node->children[0]->nodeType == Const && !node->children[0]->isArray)
	{
		// if the constant is an int or a bool
		if (node->children[0]->expType != Char)
		{
			outputRTMInstruction("LDC", 3, node->children[0]->value.num, 3, "Load Constant into ac1");
		}
		// if the constant is a char
		else
		{
			outputRTMInstruction("LDC", 3, node->children[0]->value.ch, 3, "Load Constant into ac1");
		}
	}

	// does the operation of the node
	switch (node->opKind)
	{
		case Or:
			outputInstruction("OR", 3, 3, 4, "Test if left or right side is true and store result in ac1");
			break;
		case And:
			outputInstruction("AND", 3, 3, 4, "Test if left and right sides are true and store result in ac1");
			break;
		case Less:
			if (node->children[0]->isArray && node->children[1]->isArray)
			{
				compareArrays(node->children[0], node->children[1], node);
			}
			outputInstruction("TLT", 3, 3, 4, "Test if left side is less than right side and store result in ac1");
			break;
		case Leq:
			if (node->children[0]->isArray && node->children[1]->isArray)
			{
				compareArrays(node->children[0], node->children[1], node);
			}
			outputInstruction("TLE", 3, 3, 4, "Test if left side is less than or equal to right side and store result in ac1");
			break;
		case Gtr:
			if (node->children[0]->isArray && node->children[1]->isArray)
			{
				compareArrays(node->children[0], node->children[1], node);
			}
			outputInstruction("TGT", 3, 3, 4, "Test if left side is greater than right side and store result in ac1");
			break;
		case Geq:
			if (node->children[0]->isArray && node->children[1]->isArray)
			{
				compareArrays(node->children[0], node->children[1], node);
			}
			outputInstruction("TGE", 3, 3, 4, "Test if left side is greater than or equal to right side and store result in ac1");
			break;
		case Eq:
			if (node->children[0]->isArray && node->children[1]->isArray)
			{
				compareArrays(node->children[0], node->children[1], node);
			}
			outputInstruction("TEQ", 3, 3, 4, "Test if left side is equal to right side and store result in ac1");
			break;
		case Neq:
			if (node->children[0]->isArray && node->children[1]->isArray)
			{
				compareArrays(node->children[0], node->children[1], node);
			}
			outputInstruction("TNE", 3, 3, 4, "Test if left side is not equal to right side and store result in ac1");
			break;
		case Add:
			outputInstruction("ADD", 3, 3, 4, "Add left and right sides and store result in ac1");
			break;
		case Sub:
			outputInstruction("SUB", 3, 3, 4, "Subtract left and right sides and store result in ac1");
			break;
		case Mul:
			outputInstruction("MUL", 3, 3, 4, "Multiply left and right sides and store result in ac1");
			break;
		case Div:
			outputInstruction("DIV", 3, 3, 4, "Divide left and right sides and store result in ac1");
			break;
		case Mod:
			outputInstruction("MOD", 3, 3, 4, "Modulo left and right sides and store result in ac1");
			break;
		default:
			printf("ERROR(CodeGen): Unrecognized operator\n");
	}

	outputOpEndComment(node);
	traverseSib(node);
}

// generates code for non-array unary operators (not, neg, rand)
void genUnaryOpCode(TreeNode* node)
{
	outputOpStartComment(node);

	// load operand into ac1
	evaluateExp(node->children[0]);

	// do the operation of the node
	switch (node->opKind)
	{
		case Not:
			outputRTMInstruction("LDC", 4, 1, 4, "Load 1 into ac2");
			outputInstruction("XOR", 3, 3, 4, "Do XOR operation on ac1 and ac2 to get Not operation and store result in ac1");
			break;
		case Neg:
			outputInstruction("NEG", 3, 3, 3, "Flip the negative sign of ac1 and store result in ac1");
			break;
		case Rand:
			outputInstruction("RND", 3, 3, 3, "Get and random number between 0 and the value in ac1 - 1 and store result in ac1");
			break;
		default:
			printf("ERROR(CodeGen): Unrecognized operator\n");
	}

	outputOpEndComment(node);
	traverseSib(node);
}

// generates code for a sizeof operator
void genSizeCode(TreeNode* node)
{
	outputOpStartComment(node);

	// if the operand is a string constant, load it into memory
	if (node->children[0]->nodeType == Const)
	{
		outputLitInstruction(node->children[0]->foffset, node->children[0]->value.str, node->children[0]->size);
	}

	// load address of array into ac1
	loadArrayAddr(node->children[0], 3);
	outputRTMInstruction("LD", 3, 1, 3, "Load the size of the array (1 address above the array) into ac1");

	outputOpEndComment(node);
	traverseSib(node);
}

// generates code for a bracket operator
void genBrakCode(TreeNode* node)
{
	loadIndexAddr(node->children[0], node->children[1], false);
	outputRTMInstruction("LD", 3, 0, 3, "Load value of element");

	outputCommentWithLine(node, "END [ Expression");
	traverseSib(node);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Utility functions
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////

// evaluates expressions and then stores the result in ac1
void evaluateExp(TreeNode* node)
{
	// if node is either an expression or an assignment, evaluate that first and expect result to be in ac1
	if (node->nodeType == Assign || node->nodeType == Op)
	{
		traverseAST(node);
	}
	// if node is a function call, evaluate that first and then move the return value from r2 to ac1 (r3)
	else if (node->nodeType == Call)
	{
		traverseAST(node);
		outputRTMInstruction("LDA", 3, 0, 2, "Move the return value to ac1");
	}
	// if node is a variable, load it into ac1
	else if (node->nodeType == Id && !node->isArray)
	{
		// if the variable is stored in local or parameter space
		if (node->memSpace == Local || node->memSpace == Parameter)
		{
			outputRTMInstruction("LD", 3, node->foffset, 1, "Load variable into ac1");
		}
		// if the variable is stored in static or global space
		else
		{
			outputRTMInstruction("LD", 3, node->foffset, 0, "Load variable into ac1");
		}
	}
	// if node is a constant, load it into ac1
	else if (node->nodeType == Const && !node->isArray)
	{
		// if node is an int or a bool
		if (node->expType != Char)
		{
			outputRTMInstruction("LDC", 3, node->value.num, 3, "Load Constant into ac1");
		}
		// if node is a char
		else
		{
			outputRTMInstruction("LDC", 3, node->value.ch, 3, "Load Constant into ac1");
		}
	}
	// if node is an array, load it's address into ac1
	else
	{
		loadArrayAddr(node, 3);
	}
}

// generates code to compare 2 arrays
void compareArrays(TreeNode* lhs, TreeNode* rhs, TreeNode* op)
{
	loadArrayAddr(lhs, 3);
	loadArrayAddr(rhs, 4);

	outputRTMInstruction("LD", 5, 1, 3, "Load lhs array size into ac3");
	outputRTMInstruction("LD", 6, 1, 4, "Load rhs array size into ac4");
	outputInstruction("SWP", 5, 6, 6, "Put smaller array size into ac3");
	outputInstruction("CO", 3, 4, 5, "Compare lhs and rhs array values and put either first diff or last value if no diff in ac1 and ac2");

	outputInstruction("TNE", 5, 3, 4, "Test if the values are not equal and store result in ac3");
	outputRTMInstruction("JNZ", 5, 4, 7, "Jump to comparison op if the values are not equal");

	loadArrayAddr(lhs, 3);
	loadArrayAddr(rhs, 4);
	outputRTMInstruction("LD", 3, 1, 3, "Load size of lhs array into ac1");
	outputRTMInstruction("LD", 4, 1, 4, "Load size of rhs array into ac2");
}

// puts the address of an array into register r
void loadArrayAddr(TreeNode* array, int r)
{
	// if the array is just a local variable
	if (array->memSpace == Local)
	{
		outputRTMInstruction("LDA", r, array->foffset, 1, "Load address of array into one of the accumulators");
	}
	// if the array is parameter
	else if (array->memSpace == Parameter)
	{
		outputRTMInstruction("LD", r, array->foffset, 1, "Load address of array into one of the accumulators");
	}
	// if the array is in global space or static space
	else
	{
		// if the array is a string constant, load it into memory first
		if (array->nodeType == Const)
		{
			outputLitInstruction(array->foffset, array->value.str, array->size);
		}
		outputRTMInstruction("LDA", r, array->foffset, 0, "Load address of array into one of the accumulators");
	}
}

// puts the address of an element in an array into ac1 (uses ac1 and ac2 in the process)
void loadIndexAddr(TreeNode* array, TreeNode* index, bool printEnd)
{
	outputCommentWithLine(array, "START [ Expression");

	// if index is either an expression or an assignment, evaluate that first and expect result to be in ac1
	if (index->nodeType == Assign || index->nodeType == Op)
	{
		traverseAST(index);
	}
	// if index is a function call, evaluate that first and then move the return value from r2 to ac1 (r3)
	else if (index->nodeType == Call)
	{
		traverseAST(index);
		outputRTMInstruction("LDA", 3, 0, 2, "Move the return value index into ac1");
	}
	// if index is a variable, load it into ac1
	else if (index->nodeType == Id)
	{
		outputRTMInstruction("LD", 3, index->foffset, 1, "Load variable index into ac1");
	}
	// if index is a constant, load it into ac1
	else
	{
		outputRTMInstruction("LDC", 3, index->value.num, 3, "Load constant index into ac1");
	}

	// load address of array into rb
	loadArrayAddr(array, 4);
	outputInstruction("SUB", 3, 4, 3, "Subtract index from address of array into ac1");

	// if the print end comment flag is true, print the end comment
	if (printEnd)
	{
		outputCommentWithLine(array, "END [ Expression");
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Outputting to code file functions
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////

void outputComment(std::string comment)
{
	fprintf(codeFile, "* %s\n", comment.c_str());
}

void outputCommentWithLine(TreeNode* node, std::string comment)
{
	fprintf(codeFile, "* Line %d: %s\n", node->line, comment.c_str());
}

void outputOpStartComment(TreeNode* node)
{
	std::string op = node->value.str;
	std::string comment = "START " + op + " Expression";
	outputCommentWithLine(node, comment);
}

void outputOpEndComment(TreeNode* node)
{
	std::string op = node->value.str;
	std::string comment = "END " + op + " Expression";
	outputCommentWithLine(node, comment);
}

int outputRTMInstruction(std::string instr, int r, int d, int s, std::string comment)
{
	fprintf(codeFile, "%d:\t%s %d,%d(%d)\t%s\n", iaddr, instr.c_str(), r, d, s, comment.c_str());
	iaddr++;
	return iaddr - 1;
}

int outputRTMInstruction(int addr, std::string instr, int r, int d, int s, std::string comment)
{
	fprintf(codeFile, "%d:\t%s %d,%d(%d)\t%s\n", addr, instr.c_str(), r, d, s, comment.c_str());
	return addr;
}

int outputRTMInstruction(std::string instr, int r, char d, int s, std::string comment)
{
	std::string ch;
	switch (d)
	{
		case '\0':
			ch = "\\0";
			break;
		case '\t':
			ch = "\\t";
			break;
		case '\n':
			ch = "\\n";
			break;
		case '\'':
			ch = "\\'";
			break;
		case '\\':
			ch = "\\\\";
			break;
		default:
			ch = d;
	}
	fprintf(codeFile, "%d:\t%s %d,'%s'(%d)\t%s\n", iaddr, instr.c_str(), r, ch.c_str(), s, comment.c_str());
	iaddr++;
	return iaddr - 1;
}

int outputInstruction(std::string instr, int r, int s, int t, std::string comment)
{
	fprintf(codeFile, "%d:\t%s %d,%d,%d\t%s\n", iaddr, instr.c_str(), r, s, t, comment.c_str());
	iaddr++;
	return iaddr - 1;
}

void outputLitInstruction(int addr, char* str, int size)
{
	fprintf(codeFile, "%d:\tLIT %s\n", abs(addr), str);
	goffset -= size;
	if (!inFunc)
	{
		foffset = goffset;
	}
}